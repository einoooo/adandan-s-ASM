  ;将BUFFER中的16位二进制数，每一位转化为ASCII码值，存在STR字符串中，并显示在屏幕上
  ;BUFFER是一个数据串，STR是一个字符串，从00001100到'00001100'，数据串中的1就是字符串中的31H,0是30H
  
  START:
  MOV DI,STR
  PUSH DI
  MOV CX,LENGTH ATR
  PUSH CX
  MOV AL,30H;把零送给AL
  REP STOSB     ;一个循环，用AL填充目标字符串（因为是字符串，所以是用ASC码值的0）
  POP CX
  POP DI
  MOV AL,31H     ;把1送给AL
  MOV BX,BUFFER
  
  AGAIN:
  RCL BX,1      ;BX位置加一，并把之前位的符号送给CF，作为下一个JUMP的标志
  JNC NEXT      ;0跳转
  MOV [DI],AL   ;为1就把当前位修改为1
  
  NEXT:
  INC DI        ;为零就不修改
  LOOP AGAIN
  
  MOV AL,'$'    ;结束标志？
  MOV [DI],AL
  
  MOV DX,OFFSET STR
  MOV AH,9
  INT 21H       ;显示的操作，先把对象放到DX里，然后调用9号操作
  MOV AH,4CH
  INT 21H
  
  --------------------------------------------------------------------------------------------------------
  ;一个字符串，从串中取出每一个字符，检查字符中包含1的个数，若为偶数，最高位为0，否则最高位为1
  --------------------------------------------------------------------------------------------------------
  ;十六进制3FE0H转十进制算法，存入堆栈
  ;不停地把数用10来除，商放位数上，余保留，下次把余当成被除数，直到余为0
  
  MOV AX,3FE0H      ;初始被除数
  MOV CX,0
  MOV BX,10
  
  LOOP:
  MOV DX,0          ;DX用来放余，要先清零
  DIV BX
  PUSH DX           ;把余压栈（按顺序存，按权位读出来就行了）
  INC CX            ;有什么用？
  OR AX,AX          ;检验商是否为0
  JNZ LOOP
  MOV AH,4CH
  INT 21H
  --------------------------------------------------------------------------------------------------------
